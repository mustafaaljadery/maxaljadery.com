# Design Key Value Store

## Functional Requirements
- A system that can store key-value pairs. 
- You should be able to store, retreive, and delete a key-value pair. 

## Non-functional Requirements
- High availability
- Low latency
- Consistency 

## Back of Envelope Estimation
- Storage: 1 billion keys, 1kb per key-value pair.
- 1 billion * 1kb = 1TB
- 10000 requests per second.
- 1000 writes per second.

## High Level Design

<img src="/system-design/key-value-highlevel.png"/>

### Database
- We want to store everything in memory because we want to have high latency. 
- Depending on the size of the data we want to use, we can do sharding of the data.

## Detailed Design

<img src="/system-design/key-value-deep-dive.png" />

## Tradeoffs, Bottlenecks, Summary

### Tradeoffs
- We are storying everything memory, which is more expensive and non-persistent, however it is a lot faster.

### Bottlenecks
- The more data you data, the more memory you need. This means you will use consistent hashing to shard the data, and add more to the ring the more servers you add. 

### Summary
We have a key-value store that allows us to store, retreive, and delete key-value pairs.